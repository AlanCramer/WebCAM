<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title> ACTP Documentation </title>
    
    <link href="css/style1.css" rel="stylesheet">
    <script src="vendor/d3/d3.min.js"></script>
    
    <style>

    html {
        min-width: 600;
    }
    
    body {
        width:600px;
        margin: 20px auto;
    }
    
    #px-container {
        margin-left:10px;
        width: 532px;
    }
    
    svg {

      float: left;
      border-bottom: solid 1px #ccc;
      border-right: solid 1px #ccc;
      border-top: solid 1px #ccc;
      border-left: solid 1px #ccc;
      margin-right: -1px;
      margin-bottom: -1px;
      fill: #bbb;
    }

    button{
        background-color:#038;
        color:#fff;
        font-size: 18px;
        border: none;
        border-radius: 8px;
        padding:8px;
        padding-left:12px;
        padding-right:12px;
        cursor:pointer;
    }
    
    </style>
    
</head>

<body>
    <h1 id="body-title" class="title">What is a Distance Transform</h1>
    
    <div class="section content">
        <h1>It's about the pixels</h1>
    
        <p class="content"> 
        Key to the toolpathing strategy is converting the scene to a set of boxes where the distance from the do-not-touch region can be calculated. This is the first step in 'vectorizing' the image. 
    
        <p>
        Click and drag to "color" a region. Then start the algorithm.
        
        <button onclick="OnStart()" >Start</button>
        
        <p>
        <div id="px-container"></div>
        
    <script>
        
        var pxW = 32;
        var pxH = 32;
        
        var gridW = 16;
        var gridH = 16;
        
        var data = d3.range(gridW*gridH).map(function(i) { return {x: pxW / 2, y: pxH / 2, val: -1}; }) 
        
        var pxContainer = d3.select("#px-container");
        
        var isMouseDown = false;
        var drawMode = true;
        
        var svgs = pxContainer.selectAll("svg")
            .data(data)
        .enter().append("svg")
            .attr("width", pxW)
            .attr("height", pxH)
            .attr("id", function(d, i) { return "svg" +i;})
            .on("mousedown", function() {
                isMouseDown = true;
                d3.event.preventDefault();
                
                var thisSel = d3.select(this);
                var d = thisSel.datum();
                drawMode = (d.val < 0);
                
            })
            .on("mouseup", function() {
                isMouseDown = false;
            })
            .on("mouseover", function() { 
            
                if (isMouseDown) {
                    var thisSel = d3.select(this);
                    var thisSelData = thisSel.data()[0];
                    var val = thisSelData.val;
                    
                    val = drawMode ? 0 : -1;
                    
                    thisSelData.val = val;
                    var clr = val === 0 ? "#009"  : "#fff";
                    thisSel.select("text").text(val);                    
                    thisSel.style("background", clr);
                }
            })                
        ;
            
        svgs.append("text")
            .attr("x", pxW/2)
            .attr("y", (3/4)*pxH)
            .style("text-anchor", "middle")
            .text(function(d,i) { 
                return d.val; })
        ;
        
        function updateElem(id, val) {
        
            var svg = d3.select("#svg" + id)
                .datum(val)
                .transition()
                .delay(function(d, i) { return id*300; })
                .style("background", "#990")
                .transition()
                .style("background", "#fff")
                ;
                
            svg.select("text").transition().delay(function(d, i) { return id*300; }).text(val);    
        }
    
        function OnStart() {
        
            var inArr = data.map(function(obj) { return obj.val} ) ;
            var outArr = data.map(function(obj) { return obj.val} ) ;
            var g = { 
                data: outArr,
                width: gridW 
            };
            
            inArr.width = gridW;
            inArr.getAt = function(x,y) {
                return this[this.width*y + x];
            }
        
            console.log(outArr);
            
            m = gridW;
            n = gridH;

            maxGVal = m + n;

            // phase 1 - define g(i,j)
            //  todo - last column is uninitialized, what should it be?
            for (i = 0; i < m; i += 1) {

                g.data[i] = (inArr.getAt(i, 0) === 0) ? 0 : maxGVal;
                updateElem(i, g.data[i]);
//                for (j = 1; j < n; j += 1) {
//                    g.data[j * g.width + i] = (inGreyImg.getAt(i, j) === 0) ? 0 : 1 + g.getAt(i, j - 1);
//                }
//
//                for (j = n - 1; j >= 0; j -= 1) {
//                    if (g.getAt(i, j+1) < g.getAt(i,j)) {
//                        g.data[j * g.width + i] = 1 + g.getAt(i, j + 1);
//                    }
//                }
            }
        }
        
    
    </script>
    
    </div> <!-- content-container -->
</body>

</html>
